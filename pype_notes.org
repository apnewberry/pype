#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC


* TODO Use =parso= instead of =tokenize=
* TODO Consider =concurrent.futures=,
* TODO Consider async, perhaps twisted/trio
#+BEGIN_SRC shell
python -c 'from pprint import pprint; import pype.testing.client; pprint(list(pype.testing.client.get_many([f"http://localhost:8080/{i}" for i in range(5)])))'

#+END_SRC

#+RESULTS:
: ['Hello, 0. You are client number 1065 for this server.',
:  'Hello, 1. You are client number 1065 for this server.',
:  'Hello, 2. You are client number 1065 for this server.',
:  'Hello, 3. You are client number 1065 for this server.',
:  'Hello, 4. You are client number 1065 for this server.']


#+BEGIN_SRC shell
pype ' str.split || tmp_client.get_many || list || pprint.pprint  ' < pype/testing/data/inline_urls.txt
#+END_SRC

#+RESULTS:
#+begin_example
['Hello, a. You are client number 1088 for this server.',
 'Hello, bb. You are client number 1088 for this server.',
 'Hello, ccc. You are client number 1088 for this server.']

['Hello, a. You are client number 1091 for this server.',
 'Hello, bb. You are client number 1091 for this server.',
 'Hello, ccc. You are client number 1091 for this server.']

['Hello, a. You are client number 1094 for this server.',
 'Hello, bb. You are client number 1094 for this server.',
 'Hello, ccc. You are client number 1094 for this server.']

['Hello, a. You are client number 1097 for this server.',
 'Hello, bb. You are client number 1097 for this server.',
 'Hello, ccc. You are client number 1097 for this server.']
#+end_example


#+BEGIN_SRC shell
pype --async ' str.split || tmp_client.get_many || list || pprint.pprint  ' < pype/testing/data/inline_urls.txt
#+END_SRC

* TODO Fix quote syntax

** TODO Use =parso=.


** Quoting approaches

#+BEGIN_SRC ipython
"""

$ echo 'a.b.c' | pype 'str.replace(?, ".", "!")'
a!b!c

"""

import sys

import click


def parse_command(command):
    fnstr = 'lambda placeholder: ' + command.replace('?', 'placeholder')
    return eval(fnstr)


def main(in_stream, command):
    process = parse_command(command)
    for line in in_stream:
        yield process(line)


@click.command()
@click.option('--import', '-i', 'import_')
@click.argument('command')
@click.argument('in_stream', default=click.get_text_stream('stdin'))
def cli(import_, command, in_stream):

    gen = main(in_stream, command)
    for line in gen:
        print(line)


cli()
#+END_SRC

** Two =eval()= calls
#+BEGIN_SRC python

def do(command, data):
    a = 'lambda PLACEHOLDER: command.replace("?", PLACEHOLDER)'
    b = eval(a, {'command': command})
    c = b(data)
    d = eval(c)
    return d
print(do('str.upper("?")', 'xyz') == 'XYZ')
print(do('str.upper(?)', 'xyz') == 'XYZ')
#+END_SRC

#+RESULTS:
: True
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "/tmp/babel-31866NJj/python-31866KrV", line 9, in <module>
:     print(do('str.upper(?)', 'xyz') == 'XYZ')
:   File "/tmp/babel-31866NJj/python-31866KrV", line 6, in do
:     d = eval(c)
:   File "<string>", line 1, in <module>
: NameError: name 'xyz' is not defined

** Two =eval()= calls with local data
#+BEGIN_SRC python
def do(command, data):
    a = 'lambda PLACEHOLDER: command.replace("?", PLACEHOLDER)'
    b = eval(a, {'command': command})
    c = b(data)
    d = eval(c, {data:data})
    return d
print(do('str.upper("?")', 'xyz'))
print(do('str.upper(?)', 'xyz'))

#+END_SRC

#+RESULTS:
: XYZ
: XYZ

** Two =eval= calls other way around

#+BEGIN_SRC python
from pprint import pprint as pp
def do(command, data):
    a = """lambda PLACEHOLDER: 'command.replace("?", PLACEHOLDER)'"""
    b = eval(a, {'command': command})
    c = b(data)
    d = eval(c, {'PLACEHOLDER': data, 'command': command})
    e = eval(d)
    pp(locals())
    return e
print(do('str.upper("?")', 'xyz'))


#+END_SRC

#+RESULTS:
: {'a': 'lambda PLACEHOLDER: \'command.replace("?", PLACEHOLDER)\'',
:  'b': <function <lambda> at 0x7f3ed6a92ea0>,
:  'c': 'command.replace("?", PLACEHOLDER)',
:  'command': 'str.upper("?")',
:  'd': 'str.upper("xyz")',
:  'data': 'xyz',
:  'e': 'XYZ'}
: XYZ

** One call


#+BEGIN_SRC python
from pprint import pprint as pp
def do(command, data):
    a = command.replace('?', data)
    b = eval(a, {})
    pp(locals())
    return b
print(do("""str.upper('?')""", 'xyz'))


#+END_SRC

#+RESULTS:
: {'a': "str.upper('xyz')",
:  'b': 'XYZ',
:  'command': "str.upper('?')",
:  'data': 'xyz'}
: XYZ

** fstrings

#+BEGIN_SRC shell
printf Bob | pype $'f"I said, \'hello, {?}\'".lower()'
#+END_SRC

#+RESULTS:
: i said, 'hello, bob'



* TODO Add setup and teardown
Possibly with =exec=
* TODO Remove this =f'{_PYPE_VALUE}'=
* Maybe single-line inputs shouldn't get a newline
* TODO Use True/False instead of yes/no in main()
